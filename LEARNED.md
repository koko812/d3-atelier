# 📘 LEARNED.md — D3.jsで感染伝播シミュレーションを作るまでの学習ログ ver. 2

---

## 🧠 スタートの動機

* p5.jsやVJツールに関心を持ち、そこからJavaScriptを使った**ジェネラティブアート**に興味が拡がった。
* さまざまな可視化・アニメーション系ライブラリ（p5.js / D3.js / GSAP / Anime.js / SVG）を比較検討。
* **D3.js** に着目：「データ構造を視覚化する力強いツール」として採用。

---

## 🔎 D3.js 概要と比較

| 観点      | D3.js                  | p5.js          |
| ------- | ---------------------- | -------------- |
| 主な用途    | データ可視化 / SVG操作         | 直感的なビジュアル・アート  |
| 描画先     | SVG / DOM              | Canvas         |
| 学習曲線    | やや高い                   | 優しい            |
| アニメーション | `transition()`による明示的指定 | `draw()`内で随時描画 |

---

## ✨ 最初のステップ

* SVGに `rect` 要素を配置して**グリッドアート**を生成。
* `for` ループによる `x`, `y` 位置計算。
* `hsl(...)` による色のランダム化で"色彩の網目"を作成。

```js
svg.append("rect")
  .attr("x", ...)
  .attr("y", ...)
  .attr("fill", `hsl(${Math.random()*360}, 100%, 50%)`)
```

---

## 🧠 SVGの基本と補足技術

* `d3.select("svg")` でSVGノード選択
* `<script defer>` を使用：**HTML構造が構築されたあとにJSを実行**
* `+svg.attr("width")`：`+`は文字列→数値変換の省略記法

---

## 🔥 グラフ構造と感染伝播へ

### 📌 ノードとリンクの構築

```js
const nodes = d3.range(N).map(i => ({ id: i }));
const links = [...手動 or ランダム生成...];
```

* `forceSimulation()` により物理モデル（バネ構造）を使った自然なレイアウト配置を実現。
* `fx` / `fy` によってノード固定も可能。トランポリン・クレーン構造のモックも可能。

### 💡 `.force("link", ...)` の構文

```js
d3.forceLink(links)
  .id(d => d.id)     // IDを元にリンク先を対応
  .distance(80)     // バネの自然長
```

---

## 🧪 感染伝播の実装

### 👾 基本仕様

* `infected` フラグをノードに追加
* 起点ノード（例: `id = 0`）から感染開始
* `setTimeout` による段階的な波及処理

```js
function infect(nodeId, delay = 0, fromId = null) {
  // 再感染防止
  if (!node || node.infected) return;
  node.infected = true;

  // 対象ノードを赤く染める
  nodeSelection.filter(d => d.id === nodeId)
    .transition()
    .delay(delay)
    .duration(300)
    .attr("fill", "crimson");

  // fromId 経由で感染したリンクも赤くする
  if (fromId !== null) {
    linkSelection.filter(...)  // → 太く、赤に、点線など
  }

  // 感染経路アニメーション（粒子）
  svg.append("circle")
    .attr("cx", source.x)
    .attr("cy", source.y)
    .transition()
    .attr("cx", target.x)
    .attr("cy", target.y)
    .remove();

  // 近隣ノードに感染を伝播
  neighbors.forEach(...)
}
```

---

## 🌈 可視化の深化ポイント

* `.transition()` によるリンク色変更
* `stroke-dasharray`, `stroke-dashoffset` を使って"波が流れる"表現
* `svg.append("circle")` → 小粒子がリンクを移動するアニメーションを実現！

---

## ❗ トラブルシューティング

| 問題                              | 原因                                  | 解決策                                   |
| ------------------------------- | ----------------------------------- | ------------------------------------- |
| ノードが赤くならない                      | `d3.selectAll("circle")` が粒子まで含んでいた | `nodeSelection.filter(...)` に修正       |
| `node.filter is not a function` | 変数名 `node` がデータ用と衝突                 | `targetNode`, `nodeSelection` で明示的に分離 |

---

## 💡 洞察と気づき

* グレーのままのリンク → "接続されているが実際に感染には使われなかった経路"
* 感染伝播の**構造と動きのズレ**を視覚的に発見できた
* 力学的なレイアウトと情報拡散のような**抽象概念のシミュレーション**が結びつく面白さ

---

## 🔭 今後やりたい展開案（議論中に出たアイデアも含む）

| アイデア                   | 概要                                   |
| ---------------------- | ------------------------------------ |
| 🔁 回復や再感染処理            | `setTimeout` で色を戻す、二次感染を許可する         |
| 🔍 感染履歴の記録             | `infectedFrom`, `time` を記録し、感染ツリーを再現 |
| 📈 ログの出力               | 感染経路を配列で記録し、CSVやDOMに描画               |
| 🖱️ ユーザー選択起点           | クリックしたノードから感染スタート可能にする               |
| 🌈 色のグラデーション           | 感染時間に応じて色相をずらす演出                     |
| 🎞️ 粒子のアニメ強化           | 点滅 / 残像 / ブラーエフェクトを加える               |
| 💬 ノードに名前やデータをつける      | 思考ノード・論文タイトルなどを追加表示                  |
| 📚 知識グラフ / 引用ネットワークに応用 | ノード＝論文、リンク＝引用関係とみなす                  |
| ⏱️ タイムスライダー            | 時系列で感染の進行を操作可能にするUI                  |

---

## 🚀 学びのまとめ

このプロジェクトを通じて：

* D3.js の構造的思考と DOM 操作の精密さを習得
* 可視化とは\*\*見た目以上に「構造の可視化」\*\*であると実感
* 粒子・リンク・ネットワークの動きと意味をリンクさせることで

  > **「構造 × 動き × 意味」の三位一体**が完成した

次は、リアルなデータを取り込んで、さらに世界に踏み出そう。

👏 Great Job, self!

</br>
</br>
</br>
</br>
</br>

# 🧠 D3.js グリッド学習ログ（2025年5月）

---

## ✨ 初期の問い：JavaScriptでジェネラティブアートを作るための技術は？

グリッドアートをジャバスクリプトで作るときに使える、以下のような技術を紹介。

| 技術             | リリース年    | コミュニティ活動 | 特徴                          |
| -------------- | -------- | -------- | --------------------------- |
| **p5.js**      | 2014     | ★★★★☆    | 教育、アート向け。Processing直系       |
| **Three.js**   | 2010     | ★★★★★    | WebGL抽象化、3Dのですとでも最高         |
| **Canvas API** | 2005     | ★★★☆☆    | HTML5標準。ミニマル表現に向く           |
| **D3.js**      | 2011     | ★★★★☆    | データ駆動型。SVG表現に有利             |
| **GSAP**       | 2008     | ★★★★☆    | アニメ、ユーザーインタラクションに強い         |
| **Anime.js**   | 2016     | ★★★☆☆    | 軽量、シンプル。SVGもサポート            |
| **SVG**        | 1999年標準化 | ★★★★☆    | CSS/JSで操作可能なベクターグラフィック      |
| **Hydra.js**   | 2019     | ★★★☆☆    | VJ/ライブコーディングに特化             |
| **Tone.js**    | 2014     | ★★★☆☆    | WebAudioAPI拡張。音与動きを連動させたい人に |

---

## 🔍 D3.js と p5.js の比較

| 観点         | D3.js                         | p5.js                       |
| ---------- | ----------------------------- | --------------------------- |
| 概要         | データ駆動型の可視化・SVG生成ライブラリ         | Processing直系のビジュアルプログラミング環境 |
| 主な用途       | データ可視化、インタラクティブ図、構造的アート       | アート、アニメーション、教育、表現作品         |
| 描画先        | SVG（または HTML, Canvas）         | Canvas（2D）                  |
| データ構造との親和性 | ◎ データ配列・構造に基づく要素生成が得意         | △ 自分でループを書く必要がある            |
| 学習コスト      | やや高め（enter, update, exit の概念） | やさしい（座標を描けば即座に結果が見える）       |
| アニメーション    | トランジションやスケールなど、やや手間           | `draw()` ループで簡単に実現可能        |
| インタラクション   | D3イベントや外部ライブラリと併用             | `mousePressed()` など内蔵関数が豊富  |
| コード構造      | DOMとの結合が強い                    | スケッチベースで独立                  |

### ✅ まとめ

* D3.js は「**構造やデータに基づいた図形やアート**」に強く、p5.js は「**感覚的・時間的・動的なアート**」に向く。
* **論理・構造の快楽**が好きなら D3.js、**表現・アニメの快楽**が好きなら p5.js から始めるのがよい。
* 組み合わせて使うことも可能。


## ✅ スタート地点：D3.jsとは？

* **D3.js（Data-Driven Documents）** は、JavaScript で SVG, HTML, CSS を使った **インタラクティブな可視化**を構築するためのライブラリ。
* データを元に要素を生成する思想（.data() → .enter() → .append()）がコア。
* 一方で、自由度が高い分、初学者にはややとっつきにくい側面も。

---

## ✅ コッホ曲線の描画

### 📄 ファイル構成

* `index.html`
* `main.js`
* 外部CDNから d3.v7 を読み込み

### 🔁 機能

* 初期状態は一本の直線
* 「Next Step」ボタンをクリックするたびに `kochTransform()` によって線分が 1→4 に分割される
* 再帰的に再描画され、コッホ曲線が生成されていく

### 🚩 問題と気づき

* ページをリロードすると「止まる」現象 → 実際は描画が初期化されているだけ
* ただし、その後「スピナーが回り続ける」バグが一時発生 → キャッシュまたはファイル読み込み失敗だった可能性。自然復旧。
* コードの分離（HTML/JS）を徹底することに決定

### 🧠 補足

* `kochTransform` は1本の線を4本に分けるので、ステップごとに線分数が 4^n で指数的に増える
* DOMノード（SVG `<line>`）が多くなりすぎると、ブラウザが重くなる（約4000本以降注意）

---

## ✅ defer属性について

```html
<script defer src="main.js"></script>
```

* `defer` を付けると、HTMLの読み込み完了後に JS が実行される
* DOM取得タイミングが安定し、`querySelector()` が null を返すようなミスを防げる
* 複数スクリプトがあっても、読み込み順は HTML の記述順になる（async との違い）

---

## ✅ 四角形の描画 → グリッド生成へ

### 🎯 Step 1: 単一の四角形を描画

* `d3.select('svg')` → `.append('rect')`
* `x`, `y`, `width`, `height`, `fill`, `stroke` を付与

### 📦 コード構成（HTML/JS分離）

* `index.html`: svgタグだけ持つ
* `main.js`: rectを描画するロジック

### 🎯 Step 2: グリッド描画

```js
const row = 10;
const col = 10;
const size = 30;

for (let i = 0; i < row; i++) {
  for (let j = 0; j < col; j++) {
    svg.append("rect")
      .attr("x", 50 + size * j)
      .attr("y", 50 + size * i)
      .attr("width", size)
      .attr("height", size)
      .attr("fill", "skyblue")
      .attr("stroke", "black")
      .attr("stroke-width", 2);
  }
}
```

### 🎉 結果

* 10×10 の正方形グリッドが表示される
* オフセット 50px によって中央寄せに
* 綺麗な青＋黒の縁取りで見やすい

### 💡 発展アイデア（未実装）

* 色をランダムに変更する（`Math.random()` + `hsl`）
* マウスオーバーで色変化 / クリックで変形
* グリッドの各セルに異なる図形（円、線など）を配置
* 時間ベースで動くアニメーション
* `data()` / `enter()` を使ったD3流の書き方への変換

---

## 🔚 感想まとめ

* D3.js はとても強力だけど、**素直なDOM操作ではなく「データ主導でDOMを作る」考え方が肝**。
* index.html と JS を分離することで保守しやすくなり、読み込みも安定する（`defer`）。
* 小さなことでも丁寧に確認・検証して進めると、見える景色が広がる！

次はランダム要素やマウスイベントでグリッドを動的に変化させるのが良さそう！

---

## ✨ まとめ：これから

* D3.jsのコアは「データによるDOM生成」であり、グリッドや観測性をもつアート作りに最適
* 今もD3.jsは使われており，特に

  * 教育 / 研究
  * ジャーナリズム・メディア表現
  * ビジュアルデバッグやアート作品
* 以下のような流れで学ぶと良い:

  1. rectの描画
  2. 2重forでグリッド
  3. 色や大きさのランダム変化
  4. データ駆動型 (data + enter)